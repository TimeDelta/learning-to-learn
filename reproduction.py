import math
import random
from collections import defaultdict
from warnings import warn

import numpy as np
import torch
from neat.config import *
from neat.reproduction import DefaultReproduction


class GuidedReproduction(DefaultReproduction):
    """
    Standard NEAT reproduction except half of the children for each species are generated by guided evolution.
    """

    @classmethod
    def parse_config(cls, param_dict):
        return DefaultClassConfig(
            param_dict,
            [
                ConfigParameter("elitism", int, 5),
                ConfigParameter("survival_threshold", float, 0.2),
                ConfigParameter("min_species_size", int, 1),
            ],
        )

    def __init__(self, config, reporters, stagnation):
        super().__init__(config, reporters, stagnation)
        self.guide_fn = None
        self.guided_start_generation = getattr(config, "guided_start_generation", 0)

    def reproduce(self, config, species, pop_size, generation, task):
        # Filter out stagnated species, collect the set of non-stagnated
        # species members, and compute their average adjusted fitness.
        # The average adjusted fitness scheme (normalized to the interval
        # [0, 1]) allows the use of negative fitness values without
        # interfering with the shared fitness scheme.
        all_fitnesses = []
        remaining_species = []
        for stagnant_sid, stagnant_species, stagnant in self.stagnation.update(species, generation):
            if stagnant:
                self.reporters.species_stagnant(stagnant_sid, stagnant_species)
            else:
                all_fitnesses.extend(m.fitness for m in stagnant_species.members.values())
                remaining_species.append(stagnant_species)
        # Ensure the species set drops stagnated species but preserves survivors for history.
        species.species = {s.key: s for s in remaining_species}
        # The above comment was not quite what was happening - now getting fitnesses
        # only from members of non-stagnated species.

        # No species left.
        if not remaining_species:
            return {}

        # Find minimum/maximum fitness across the entire population, for use in
        # species adjusted fitness computation.
        min_fitness = min(all_fitnesses)
        max_fitness = max(all_fitnesses)
        # Do not allow the fitness range to be zero, as we divide by it below.
        # TODO: The ``1.0`` below is rather arbitrary, and should be configurable.
        fitness_range = max(1.0, max_fitness - min_fitness)
        for species in remaining_species:
            # Compute adjusted fitness.
            msf = np.mean([m.fitness for m in species.members.values()], axis=0)
            species.adjusted_fitness = (msf - min_fitness) / fitness_range

        self._log_species_metrics(remaining_species)

        adjusted_fitnesses = [s.adjusted_fitness for s in remaining_species]
        avg_adjusted_fitness = np.mean(adjusted_fitnesses, axis=0)  # type: float
        self.reporters.info("Average adjusted fitness: {:.3f}".format(avg_adjusted_fitness))

        # Compute the number of new members for each species in the new generation.
        previous_sizes = [len(s.members) for s in remaining_species]
        # Isn't the effective min_species_size going to be max(min_species_size,
        # self.reproduction_config.elitism)? That would probably produce more accurate tracking
        # of population sizes and relative fitnesses... doing. TODO: document.
        min_species_size = max(self.reproduction_config.min_species_size, self.reproduction_config.elitism)
        spawn_amounts = self.compute_spawn(adjusted_fitnesses, previous_sizes, pop_size, min_species_size)

        new_population = {}
        for spawn, s in zip(spawn_amounts, remaining_species):
            spawn = max(spawn, self.reproduction_config.elitism)
            old_members = sorted(s.members.items(), key=lambda item: item[1].fitness, reverse=True)
            # elites
            for gid, g in old_members[: self.reproduction_config.elitism]:
                new_population[gid] = g
            remaining_spawn = spawn - self.reproduction_config.elitism
            if remaining_spawn <= 0:
                continue

            # 1) guided children
            guided_quota = remaining_spawn // 2
            guided_children = []
            if guided_quota > 0 and self.guide_fn is not None and generation >= self.guided_start_generation:
                guided_children = self.guide_fn(task, list(s.members.values()), self.reproduction_config, guided_quota)

            for kid in guided_children:
                gid = next(self.genome_indexer)
                kid.key = gid
                new_population[gid] = kid
                self.ancestors[gid] = (None, None)
            remaining_spawn -= len(guided_children)
            if remaining_spawn <= 0:
                continue

            # 2) standard NEAT crossover + mutation
            if remaining_spawn > 0:
                repro_cutoff = max(2, int(math.ceil(self.reproduction_config.survival_threshold * len(old_members))))
                parents = old_members[:repro_cutoff]
                for _ in range(remaining_spawn):
                    p1_id, p1 = random.choice(parents)
                    p2_id, p2 = random.choice(parents)
                    cid = next(self.genome_indexer)
                    child = config.genome_type(cid)
                    child.configure_crossover(p1, p2, config.genome_config)
                    child.mutate(config.genome_config)
                    if hasattr(child, "compile_optimizer"):
                        child.compile_optimizer(config.genome_config)
                        graph_dict = getattr(child, "graph_dict", None)
                        if graph_dict:
                            edge_index = graph_dict.get("edge_index")
                            num_edges = 0
                            if edge_index is not None:
                                if isinstance(edge_index, torch.Tensor):
                                    edge_tensor = edge_index
                                else:
                                    edge_tensor = torch.as_tensor(edge_index)
                                if edge_tensor.dim() == 1:
                                    num_edges = edge_tensor.numel() // 2
                                elif edge_tensor.dim() == 2:
                                    num_edges = edge_tensor.size(1)
                            if num_edges == 0:
                                warn(
                                    "NEAT offspring produced an empty graph after mutation; consider adjusting mutation rates."
                                )
                    new_population[cid] = child
                    self.ancestors[cid] = (p1_id, p2_id)

        return new_population

    def _log_species_metrics(self, species_list):
        for species in species_list:
            metric_values = defaultdict(list)
            members_with_metrics = 0
            for member in species.members.values():
                metrics = getattr(member, "fitnesses", None)
                if not metrics:
                    continue
                members_with_metrics += 1
                for metric, value in metrics.items():
                    metric_name = self._metric_name(metric)
                    metric_values[metric_name].append(value)

            total_members = len(species.members)
            if not metric_values:
                self.reporters.info(
                    f"Species {species.key}: no per-metric fitness data available ({members_with_metrics}/{total_members} members)"
                )
                continue

            parts = []
            for metric_name in sorted(metric_values.keys()):
                values = metric_values[metric_name]
                mean_value = sum(values) / len(values)
                parts.append(f"{metric_name}: {mean_value:.4f}")
            joined = ", ".join(parts)
            self.reporters.info(
                f"Species {species.key} fitness metrics ({members_with_metrics}/{total_members} members contributing): {joined}"
            )

    @staticmethod
    def _metric_name(metric):
        if hasattr(metric, "name"):
            return getattr(metric, "name")
        if hasattr(metric, "__name__"):
            return getattr(metric, "__name__")
        return str(metric)
