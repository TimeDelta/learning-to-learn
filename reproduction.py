import math
import random

import numpy as np
from neat.config import *
from neat.reproduction import DefaultReproduction


class GuidedReproduction(DefaultReproduction):
    """
    Standard NEAT reproduction except half of the children for each species are generated by guided evolution.
    """

    @classmethod
    def parse_config(cls, param_dict):
        return DefaultClassConfig(
            param_dict,
            [
                ConfigParameter("elitism", int, 0),
                ConfigParameter("survival_threshold", float, 0.2),
                ConfigParameter("min_species_size", int, 1),
            ],
        )

    def __init__(self, config, reporters, stagnation):
        super().__init__(config, reporters, stagnation)
        self.guide_fn = None

    def reproduce(self, config, species, pop_size, generation, task):
        # Filter out stagnated species, collect the set of non-stagnated
        # species members, and compute their average adjusted fitness.
        # The average adjusted fitness scheme (normalized to the interval
        # [0, 1]) allows the use of negative fitness values without
        # interfering with the shared fitness scheme.
        all_fitnesses = []
        remaining_species = []
        for stagnant_sid, stagnant_species, stagnant in self.stagnation.update(species, generation):
            if stagnant:
                self.reporters.species_stagnant(stagnant_sid, stagnant_species)
            else:
                all_fitnesses.extend(m.fitness for m in stagnant_species.members.values())
                remaining_species.append(stagnant_species)
        # The above comment was not quite what was happening - now getting fitnesses
        # only from members of non-stagnated species.

        # No species left.
        if not remaining_species:
            species.species = {}
            return {}

        # Find minimum/maximum fitness across the entire population, for use in
        # species adjusted fitness computation.
        min_fitness = min(all_fitnesses)
        max_fitness = max(all_fitnesses)
        # Do not allow the fitness range to be zero, as we divide by it below.
        # TODO: The ``1.0`` below is rather arbitrary, and should be configurable.
        fitness_range = max(1.0, max_fitness - min_fitness)
        for species in remaining_species:
            # Compute adjusted fitness.
            msf = np.mean([m.fitness for m in species.members.values()], axis=0)
            species.adjusted_fitness = (msf - min_fitness) / fitness_range

        adjusted_fitnesses = [s.adjusted_fitness for s in remaining_species]
        avg_adjusted_fitness = np.mean(adjusted_fitnesses, axis=0)  # type: float
        self.reporters.info("Average adjusted fitness: {:.3f}".format(avg_adjusted_fitness))

        # Compute the number of new members for each species in the new generation.
        previous_sizes = [len(s.members) for s in remaining_species]
        # Isn't the effective min_species_size going to be max(min_species_size,
        # self.reproduction_config.elitism)? That would probably produce more accurate tracking
        # of population sizes and relative fitnesses... doing. TODO: document.
        min_species_size = max(self.reproduction_config.min_species_size, self.reproduction_config.elitism)
        spawn_amounts = self.compute_spawn(adjusted_fitnesses, previous_sizes, pop_size, min_species_size)

        species.species = {}
        new_population = {}
        for spawn, s in zip(spawn_amounts, remaining_species):
            spawn = max(spawn, self.reproduction_config.elitism)
            old_members = sorted(s.members.items(), key=lambda item: item[1].fitness, reverse=True)
            # elites
            for gid, g in old_members[: self.reproduction_config.elitism]:
                new_population[gid] = g
            spawn -= self.reproduction_config.elitism
            if spawn <= 0:
                continue

            # 1) guided children
            if spawn // 2 > 0:
                guided = self.guide_fn(
                    task.name(), task.features, list(s.members.values()), self.reproduction_config, spawn // 2
                )
                for kid in guided:
                    new_population[kid.key] = kid

            # 2) standard NEAT crossover + mutation
            if spawn - spawn // 2 > 0:
                repro_cutoff = max(2, int(math.ceil(self.reproduction_config.survival_threshold * len(old_members))))
                parents = old_members[:repro_cutoff]
                for _ in range(spawn - spawn // 2):
                    p1_id, p1 = random.choice(parents)
                    p2_id, p2 = random.choice(parents)
                    cid = next(self.genome_indexer)
                    child = config.genome_type(cid)
                    child.configure_crossover(p1, p2, config.genome_config)
                    child.mutate(config.genome_config)
                    new_population[cid] = child
                    self.ancestors[cid] = (p1_id, p2_id)

        return new_population
