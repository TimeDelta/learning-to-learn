"""
Generated by ChatGPT
"""
from typing import Dict, List

def dominates(p_vals: Dict[str, float],
              q_vals: Dict[str, float],
              objectives: Dict[str, str]
             ) -> bool:
    """Return True if p dominates q under given objectives."""
    at_least_equal = True
    strictly_better = False
    for m, obj in objectives.items():
        pv, qv = p_vals[m], q_vals[m]
        if obj == 'max':
            if pv < qv:
                at_least_equal = False
                break
            if pv > qv:
                strictly_better = True
        else:  # 'min'
            if pv > qv:
                at_least_equal = False
                break
            if pv < qv:
                strictly_better = True
    return at_least_equal and strictly_better

def nondominated_sort(metrics: Dict[int, Dict[str, float]],
                      objectives: Dict[str, str]
                     ) -> List[List[int]]:
    """
    Fast non-dominated sorting.
    Returns:
      fronts: List of Pareto fronts, each a list of genome IDs.
    """
    S = {i: [] for i in metrics} # Solutions dominated by i
    n = {i: 0 for i in metrics}  # Domination count of i
    fronts: List[List[int]] = [[]]

    # Compute S and n
    for p in metrics:
        for q in metrics:
            if p == q:
                continue
            if dominates(metrics[p], metrics[q], objectives):
                S[p].append(q)
            elif dominates(metrics[q], metrics[p], objectives):
                n[p] += 1
        if n[p] == 0:
            fronts[0].append(p)

    # Extract subsequent fronts
    i = 0
    while fronts[i]:
        next_front: List[int] = []
        for p in fronts[i]:
            for q in S[p]:
                n[q] -= 1
                if n[q] == 0:
                    next_front.append(q)
        i += 1
        fronts.append(next_front)

    # Drop empty last front
    return fronts[:-1]
